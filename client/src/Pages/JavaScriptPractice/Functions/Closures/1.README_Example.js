let name1 = "Вася"; // Глобальная переменная (уязвима к изменениям)

{
    let name2 = "Андрей"; // Локальная переменная, не доступна из вне
    console.log(`Это имя (name2) которое внутри объекта ${name2}`);
}

// console.log(name2); // Ошибка! name2 не существует здесь
console.log(`А это имя (name1) доступно из глобальной переменной ${name1}`);

// Если задача стоит у нас спрятать все наши переменные в которых хранятся данные и один раз сделать шаблон кода и в него поместить разные методы, которые должны как то работать с спрятанными данными, то мы можем это сделать с помощью замыкания. То есть мы сразу определяем с помощью методов, с какими переменными замыкающая функция будет работать и что именно делать, это даст возмоность работать с этими переменными только через эти методы и никак иначе.


// ============= СХЕМА ЗАМЫКАНИЯ =============

// Замыкание без параметров и методов
function внешняяФункция() {
    
    let локальнаяСпрятаннаяПеременная = 'Я значение внутри спрятанной переменной';

    return function внутренняяФункцияЗамыкания() {
        return локальнаяСпрятаннаяПеременная; // Делаем только доступ к переменной 
    };
}

const получитьЗначение = внешняяФункция(); // Используем нашу заготовку
console.log(получитьЗначение()); //Получаем доступ к нашей "локальнаяСпрятаннаяПеременная" с помощью функции замыкания "внутренняяФункцияЗамыкания". Это не самый полезный код.

// Замыкание с параметрами

function внешняяФункцияВместеПараметром(параметр) {
    let фиксированнаяИнформация = 'Я буду у всех';
    
    return function внешняяФункцияВместеПараметром(параметр2) {
        // Используем оба параметра и фиксированную информацию
        return `${фиксированнаяИнформация}, параметр: ${параметр}, параметр2: ${параметр2}`;
    }
}

// Пример использования
const замыкание1 = внешняяФункцияВместеПараметром('первый');
console.log(замыкание1('второй'));
console.log(замыкание1('новое значние замыкание1'));
console.log(замыкание1('новое значние замыкание2'));

const замыкание2 = внешняяФункцияВместеПараметром('замыкание2 с новым значением');
console.log(замыкание1('Каша'));
console.log(замыкание1('Борщ'));
console.log(замыкание1('Вискас'));

console.log(замыкание1(`По прежнему остается контекст с const замыкание2 = внешняяФункцияВместеПараметром ('первый') `));


// Замыкание с параметрами, методами и несколькими переменными

function сложнаяфункция(name) {
    let переменнаяЧисло = 0;
    let переменнаяМассив = [];
    let переменнаяТекст = '';
    
    return {
        методЧисла(число) {
            переменнаяЧисло += число;
            return this;
        },
        методМассива(элемент) {
            переменнаяМассив.push(элемент);
            return this;
        },
        методТекста(текст) {
            переменнаяТекст += текст;
            return this;
        },
        методВсего() {
            return {
                число: переменнаяЧисло,
                массив: [...переменнаяМассив],
                текст: переменнаяТекст
            };
        },
    };
}

const пример = сложнаяфункция('Тест');
пример
    .методЧисла(5)
    .методМассива('элемент1')
    .методТекста('Привет')
    .методЧисла(3)
    .методМассива('элемент2')
    .методТекста(' мир');

console.log(пример.методВсего());